\documentclass[11pt]{article} % Try also "scrartcl" or "paper"
\usepackage{helvet}
\linespread{1}
 \usepackage[margin=1.2cm]{geometry}   % to change margins
 \usepackage{titling}             % Uncomment both to   
 \setlength{\droptitle}{-2.3cm}     % change title position 
\usepackage[affil-it]{authblk}
\usepackage{bibentry}
\usepackage{cite}
\usepackage{graphicx,bm,times,subfig,amsmath,amsfonts,listings,url}
\usepackage{color}
\usepackage[page]{appendix}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\author{Ben Crabbe}
\affil{University of Bristol, UK}
\title{%\vspace{-1.5cm}            % Another way to do
Java Database Report}
\begin{document}


\maketitle
\section{Records}
This covers the first step of the assignment, designing a Record class.

I decided that, to be true to the relational model, the order of the fields in each record should be unimportant, therefore I stored them in a Set but I choose the LinkedHashSet so that when a certain order seemed logical the fields could be defined in that order and would be printed etc in that order automatically.

I also thought that it seemed the record should know what its fields were and not just their attributes, so I created the Attribute class, and since all instances of this class must belong to a Record I made it an inner class. 

I also created a custom exception to throw when any of the Record methods was used incorrectly, such as adding a field which already exists, or setting the value of a field which doesn't exist etc. 



\lstset{language=Java}
\lstdefinestyle{customc}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=L,
  xleftmargin=\parindent,
  language=Java,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\bfseries\color{mymauve},
  commentstyle=\itshape\color{purple!40!black},
  identifierstyle=\color{blue},
  stringstyle=\color{orange},
}
\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  language=Java,                 % the language of the code
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  %stringstyle=\color{mymauve},     % string literal style
  tabsize=2,                       % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

\begin{lstlisting}

import java.util.*;

class Record
{
   public class RecordException extends Exception
   {
      static final long serialVersionUID = 42L;
      public RecordException()
      {
         super();
      }

      public RecordException(String message)
      {
         super(message);
      }

      public RecordException(String message, Throwable cause)
      {
        super(message, cause);
      }

      public RecordException(Throwable cause)
      {
         super(cause);
      }
   }

   class Attribute
   {
      String name;
      String value;

      Attribute(String nameInput, String valueInput)
      {
         name = nameInput;
         value = valueInput;
      }
   }

    Set<Attribute> data;

    Record() {
      data = new LinkedHashSet<Attribute>();
    }

   void addField(String fieldName, String fieldValue) throws RecordException
   {
      for(Attribute field: data) {
         if(field.name==fieldName) {
            throw new RecordException("There already exists a field named " + fieldName + "in record.");
         }
      }
      Attribute newField = new Attribute(fieldName,fieldValue);
      this.data.add(newField);
   }

   String getFieldValue(String fieldName) throws RecordException
   {
      for(Attribute field: data) {
         if(field.name==fieldName) {
            return field.value;
         }
      }
      throw new RecordException("No field named " + fieldName + " in record.");
   }

   void setFieldValue(String fieldName, String fieldValue) throws RecordException
   {
      for(Attribute field: data) {
         if(field.name==fieldName) {
            field.value = fieldValue;
            return;
         }
      }
      throw new RecordException("No field named " + fieldName+ " in record.");
   }

   int countFields()
   {
      return data.size();
   }

   public static void main(String[] args)
   {
      Record row = new Record();
      row.testRecord();
   }

   void testRecord()
   {
      try {
         this.addField("Field1","value1");
         this.addField("Field2","value2");
         this.setFieldValue("Field2","value2.2");
         System.out.println(this.getFieldValue("Field1"));
         System.out.println(this.getFieldValue("Field2"));
         System.out.println( this.countFields() );
      } catch (Exception e) {
         System.out.println(e.getMessage());
      }
   }
}

\end{lstlisting}

\section{Tables}
I decided that the main data on the attribute names, types etc should be held by the table since every row is the same, so I split the Attribute class into two: Attribute and AttributeValue. Attributes hold the name (and other things in the future), AttributeValues, which are an inner class to Tuple (I renamed Record to fit better with the relational model) hold the values and a reference to the Attribute class it belongs to. This way the values are still directly searchable by attribute name, but the name is stored in only 1 place. 

I also got rid of my custom exception. It wouldn't let me pass multiple string types to store as a message, and it didn't seem to gain much to be worth writing a bunch more constructors for.




\begin{lstlisting}
import java.util.*;

class Table
{
    String name;
    List<Attribute> tableHeading;// attribute names, types, constraints etc
    Set<Tuple> tableBody;// a set of tuples
    
    Table(String name)
    {
        this.name = name;
        tableHeading = new ArrayList<Attribute>();//columns
        tableBody = new LinkedHashSet<Tuple>();//rows
    }

    Table(String name, List<String> fieldNames)
    {
        this.name = name;
        tableHeading = new ArrayList<Attribute>();
        tableBody = new LinkedHashSet<Tuple>();
        for(String newField: fieldNames) {
            try {
                addAttribute(newField);
            } catch(Exception e) {
                System.out.println(e.getMessage());
            }
        }
    }
    
    boolean attributeExists(String attributeName)
    {
        for(Attribute a: tableHeading) {
            if(a.name==attributeName) {
                return true;
            }
        }
        return false;
    }
    
    void addAttribute(String attributeName) throws Exception
    {
        if(attributeExists(attributeName)){
            throw new Exception("attribute " + attributeName + " already exists");
        }
        Attribute newAtt = new Attribute(attributeName);
        tableHeading.add(newAtt);
    }

    int countFields()
    {
       return tableHeading.size();
    }
    
    int countRows()
    {
        return tableBody.size();
    }

    List<String> getFieldNames()
    {
        List<String> fieldNames = new ArrayList<String>();
        for(Attribute field: tableHeading) {
            fieldNames.add(field.name);
        }
        return fieldNames;
    }

    void editAttributeName(String oldName, String newName) throws Exception
    {
        if(attributeExists(oldName)) {
            Attribute editMyName = getAttributeFromName(oldName);
            editMyName.name = newName;
        }
        else {
            throw new Exception("Could not edit attribute name. No attribute named " +
                                oldName + " in table.");
        }
    }

    private Attribute getAttributeFromName(String name) throws Exception
    {
        for(Attribute field: tableHeading) {
            if(field.name==name) {
                return field;
            }
        }
        throw new Exception("Could not get attribute. None named " + name + " in table.");
    }

    void addTuple(String... values) throws Exception
    {
        if(values.length != tableHeading.size()) {
            throw new Exception("addTuple() for Table " + name + " expects " +
                                    tableHeading.size() + " data values. It received " +
                                    values.length);
        }
        else {
            Tuple newTuple = new Tuple(tableHeading, Arrays.asList(values));
            tableBody.add(newTuple);
        }
    }
    
    void deleteTuple(String attributeName, String value) throws Exception
    {
        if(attributeExists(attributeName)) {
            Attribute attributeToDelete = getAttributeFromName(attributeName);
            try {
                for(Tuple row: tableBody) {
                    if(row.getAttributeValue(attributeName)==value) {
                        tableBody.remove(row);
                        return;
                    }
                }
            } catch(Exception e) {
                throw new Exception("deleteTuple() there are no tuples where " +
                                    attributeName + " has a value of " + value );
            }
        } else {
            throw new Exception("deleteTuple()  No attribute named " + attributeName +
                                " in table " + name);
        }
    }

    static void is(Object x, Object y)
    {
        if (x == y) return;
        if (x != null && x.equals(y)) return;
        throw new Error("Error:\n" + x + "\n" + y);
    }

    void testTable()
    {
        
    }

    public static void main(String[] args)
    {
        Table t = new Table("testTable");
        t.testTable();
    }


}

\end{lstlisting}

\begin{lstlisting}
import java.util.*;


class Tuple
{
   List<AttributeValue> attributes;

   class AttributeValue
   {
        String value;
        Attribute type;

        AttributeValue(Attribute attributeType, String value)
        {
           this.value = value;
           this.type = attributeType;
        }
    }


    Tuple()
    {
        attributes = new ArrayList<AttributeValue>();
    }

    Tuple( List<Attribute> tableHeading, List<String> values)
    {
        attributes = new ArrayList<AttributeValue>();
        for(int i=0; i<values.size(); ++i) {
            AttributeValue newAttribute = new AttributeValue(tableHeading.get(i), values.get(i));
        }
    }

    private AttributeValue getAttributeValueObjFromName(String attributeName) throws Exception
    {
        for(AttributeValue attribute: attributes) {
            if(attribute.type.name==attributeName) {
                return attribute;
            }
        }
        throw new Exception("No attribute named " + attributeName + " in tuple." );
    }
    
    boolean attributeExists(String name)
    {
        for(AttributeValue attribute: attributes) {
            if(attribute.type.name==name) {
                return true;
            }
        }
        return false;
    }

    String getAttributeValue(String attributeName) throws Exception
    {
        AttributeValue attribute =  getAttributeValueObjFromName(attributeName);
        return attribute.value;
    }


    void setAttributeValue(String attributeName, String attributeValue) throws Exception
    {
        AttributeValue attribute =  getAttributeValueObjFromName(attributeName);
        attribute.value=attributeValue;
    }

    int countAttributes()
    {
        return attributes.size();
    }

    void addAttribute(Attribute attributeType, String value) throws Exception
    {
        if(attributeExists(attributeType.name)) {
            throw new Exception("addAttribute() attribute named " + attributeType.name +
                                " already exists in tuple.");
        }
        AttributeValue newAttribute = new AttributeValue(attributeType,value);
        attributes.add(newAttribute);
    }
    static void is(Object x, Object y)
    {
        if (x==y || (x != null && x.equals(y)) ) {
            System.out.println("pass");
            return;
        }
        System.out.println("fail");
        throw new Error("Error:\n" + x + "\n" + y);
    }

    public static void main(String[] args)
    {
        Tuple row = new Tuple();
        row.testTuple();
    }

    void testTuple()
    {
        try {
            Attribute newAttribute = new Attribute("test");
            addAttribute(newAttribute,"value1");
            is(1,countAttributes());
            is("value1",getAttributeValue("test"));
            setAttributeValue("test", "value2");
            is("value2",getAttributeValue("test"));
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }
}

\end{lstlisting}

\begin{lstlisting}
import java.util.*;

class Attribute
{
    String name;
    //      String type;
    
    Attribute(String name)
    {
        this.name = name;
        //   this.value = type;
    }
}
\end{lstlisting}











\section{FIles} 
To handle table saving, loading and exporting I have made a FileHandler class. 





\subsection{Saving}
To save files I added a toSaveString() method to Table class, 

\begin{lstlisting}
    String toSaveString()
    {
        String tableString = name + "||";
        try {
            List<String> attNames = getAttributeNames();
            for(String column: attNames) {
                tableString = tableString.concat(column);
                tableString = tableString.concat("|");
            }
            tableString = tableString.concat("|");
            for(Tuple row: tableBody) {
                for(String attName: attNames) {
                    tableString = tableString.concat(row.getAttributeValue(attName));
                    tableString = tableString.concat("|");
                }
                tableString =  tableString.concat("|");
            }
        } catch(Exception e) {
            System.out.println(e.getMessage());
            throw new Error();
        }
        return tableString;
    }
\end{lstlisting}

I used a single pipe( "$\mid$" ) to delimit columns, and double for rows these were defined in the FileHandler class:
\begin{lstlisting}

    final static private String encoding = "UTF-8";
    final static String newLineDelim = Pattern.quote("||");
    final static String columnDelim = Pattern.quote("|");
\end{lstlisting}

To stop field names containing pipes I added a method isValidName() which all attribute values and names, and table names were passed through before being set.

\begin{lstlisting}
   static boolean isValidName(String name) throws Exception
    {
        if( name.contains(FileHandler.columnDelim) ||
           name.contains(FileHandler.newLineDelim) ) {
            throw new Exception(name + " is invalid. names cannot contain any of: " +
                                FileHandler.columnDelim + FileHandler.newLineDelim);
        }
        else return true;
    }
\end{lstlisting}


The FileHandlerClass is then used to save the table. saveTableToFile() provides a descriptive interface, whilst stringToFile() to which it delegates the actual io , is generic and reusable.
\begin{lstlisting}

    void saveTableToFile(Table t, String fpath)
    {
        stringToFile( t.toSaveString(), fpath);
    }

    private void stringToFile(String s, String fpath)
    {
        Writer writer = null;
        try {
            writer = new BufferedWriter(
                        new OutputStreamWriter(
                            new FileOutputStream(fpath), encoding));
            writer.write(s);
        } catch (IOException e) {
            System.out.println(e.getMessage());
        } finally {
            try {
                writer.close();
            } catch (Exception e) {
                System.out.println(e.getMessage());
            }
        }
    }
\end{lstlisting}






\subsection{Loading}

Loading from the produced save strings is handled similarly. A generic method readFile() gets all the text form a file:

\begin{lstlisting}
    static String readFile(String fpath) throws IOException
    {
        byte[] encoded = Files.readAllBytes(Paths.get(fpath));
        return new String(encoded, encoding);
    }
    
\end{lstlisting}

and a function which splits the saved string up and builds the table which it returns. I think that theres perhaps too much detailed table handling for this to be in the FileHandler class, it could be better to just pass the file string to a constructor and let the Table class deal with it, but there is already a constructor that accepts a single String and sets just the table name. So I am going to leave it like this until I have worked out how users will create tables.

\begin{lstlisting}
    Table loadTableFromFile(String fpath)
    {
        try {
            String tableString = new String(readFile(fpath));
            String[] tableRowStrings = tableString.split(newLineDelim);
            String[] tableHeadings = tableRowStrings[1].split(columnDelim);
            Table newTable = new Table(tableRowStrings[0],//[0] has table name
                                       Arrays.asList(tableHeadings));
            for(int i=2; i<tableRowStrings.length; ++i) {
                newTable.addTuple(tableRowStrings[i].split(columnDelim));
            }
            return newTable;
        } catch (Exception e) {
            System.out.println(e.getMessage());
            throw new Error();
        }
    }

\end{lstlisting}




\subsection{Printing/Exporting}

FileHandler provides the interface:


\begin{lstlisting}
    void exportTableAsTxt(Table t, String fpath)
    {
        List<String> rowStrings = t.presentTableForPrinting();
        stringListToFile(rowStrings, fpath);
    }
\end{lstlisting}

which just uses the stringToFileMethod I already wrote:

\begin{lstlisting}
    private void stringListToFile(List<String> strList, String fpath)
    {
        String combined = "";
        for(String str: strList) {
            combined = combined.concat(str);
        }
        stringToFile(combined,fpath);
    }
    
\end{lstlisting}

the table handles the formatting:

\begin{lstlisting}
    private int spacesBetweenCols = 4;

    List<String> presentTableForPrinting()
    {
        List<String> presentedTable = new ArrayList<String>();
        List<String> headings = getAttributeNames();
        List<Integer> headingWidths = getColumnWidths(headings);
        
        presentedTable.add(name);
        presentedTable.add("\n\n\n");
        
        presentedTable.add(presentTableRow(headings, headingWidths));
        presentedTable.add( makeStringOfChar( getTableWidth(headingWidths), '-') + "\n" );
        
        for(Tuple row: tableBody) {
            List<String> rowString = row.toListOfStrings();
            presentedTable.add(presentTableRow(rowString, headingWidths));
        }
        return presentedTable;
    }
    
    private int getTableWidth(List<Integer> headingWidths)
    {
        int sum = 0;
        for(int headingWidth : headingWidths) {
            sum += headingWidth;
        }
        sum +=spacesBetweenCols*countColumns();
        return sum;
    }
    
    private String presentTableRow(List<String> rowStrings, List<Integer> headingWidths)
    {
        String presentedRow = "";
        for(int i=0; i<rowStrings.size(); ++i)
        {
            int strWidth = getWidthOfString(rowStrings.get(i));
            int spacesNeeded = headingWidths.get(i) - strWidth;
            presentedRow = presentedRow.concat(rowStrings.get(i));
            presentedRow = presentedRow.concat(makeStringOfChar(spacesNeeded+spacesBetweenCols, ' '));
        }
        presentedRow += '\n';
        return presentedRow;
    }
    
    private String makeStringOfChar(int number, char c)
    {
        String s = "";
        for(int i=0; i<number; ++i)
        {
            s = s + c;
        }
        return s;
    }
    
    private List<Integer> getColumnWidths(List<String> headings)
    {
        List<Integer> headingWidths = new ArrayList<Integer>();
        for(String heading: headings) {
            headingWidths.add(getWidthOfString(heading));
        }
        return headingWidths;
    }
    
    private int getColumnWidth(String attributeName) throws Exception
    {
        Attribute a = getAttributeFromName(attributeName);
        int maxwidth = getWidthOfString(attributeName);
        for(Tuple row: tableBody) {
            String valueString = row.getAttributeValue(attributeName);
            int width = getWidthOfString(valueString);
            maxwidth = width > maxwidth ? width : maxwidth;
        }
        return maxwidth;
    }

    static int getWidthOfString(String str)
    {
        int width=0, maxwidth=0;
        for( char c: str.toCharArray() ) {
            if(c=='\n' || c=='\r') {
                maxwidth = width > maxwidth ? width : maxwidth;
                width = 0;
            }
            else {
                ++width;
            }
        }
        maxwidth = width > maxwidth ? width : maxwidth;
        return maxwidth;
    }

\end{lstlisting}

an example of the output is: 



\begin{lstlisting}
testTable2


Attribute1    Att2    A3    
----------------------------
value1        val1    v1    
value2        val2    v2    

\end{lstlisting}

Here is the full module:

\begin{lstlisting}


import static java.nio.file.StandardOpenOption.*;
import java.nio.*;
import java.nio.channels.*;
import java.nio.file.*;
import java.nio.file.attribute.*;
import java.io.*;
import java.util.*;
import java.lang.Object;
import java.util.regex.Pattern;

class FileHandler
{
    final static private String encoding = "UTF-8";
    final static String newLineDelim = Pattern.quote("||");
    final static String columnDelim = Pattern.quote("|");
    
    FileHandler()
    {
        
    }
    
    void exportTableAsTxt(Table t, String fpath)
    {
        List<String> rowStrings = t.presentTableForPrinting();
        stringListToFile(rowStrings, fpath);
    }
    
    private void stringListToFile(List<String> strList, String fpath)
    {
        String combined = "";
        for(String str: strList) {
            combined = combined.concat(str);
        }
        stringToFile(combined,fpath);
    }
    
    void saveTableToFile(Table t, String fpath)
    {
        stringToFile( t.toSaveString(), fpath);
    }
    
    private void stringToFile(String s, String fpath)
    {
        Writer writer = null;
        try {
            writer = new BufferedWriter(
                        new OutputStreamWriter(
                            new FileOutputStream(fpath), encoding));
            writer.write(s);
        } catch (IOException e) {
            System.out.println(e.getMessage());
        } finally {
            try {
                writer.close();
            } catch (Exception e) {
                System.out.println(e.getMessage());
            }
        }
    }
    
    static private List<String> trimWhiteSpace(String[] oldStrings)
    {
        List<String> newStrings = new ArrayList<String>();
        for(String s: oldStrings) {
            newStrings.add(s.trim());
        }
        return newStrings;
    }
    
    Table loadTableFromFile(String fpath)
    {
        try {
            String tableString = new String(readFile(fpath));
            String[] tableRowStrings = tableString.split(newLineDelim);
            String[] tableHeadings = tableRowStrings[1].split(columnDelim);
            Table newTable = new Table(tableRowStrings[0],//[0] has table name
                                       Arrays.asList(tableHeadings));
            for(int i=2; i<tableRowStrings.length; ++i) {
                newTable.addTuple(tableRowStrings[i].split(columnDelim));
            }
            return newTable;
        } catch (Exception e) {
            System.out.println(e.getMessage());
            throw new Error();
        }
    }
    
    static String readFile(String fpath) throws IOException
    {
        byte[] encoded = Files.readAllBytes(Paths.get(fpath));
        return new String(encoded, encoding);
    }
    
    void testReadFile()
    {
        testSaveTable();
        try {
            String file = readFile("./saves/test.txt");
            System.out.println(file);
        } catch (Exception e) {
            System.out.println(e.getMessage());
            throw new Error();
        }
    }
    
    void testSaveTable()
    {
        List<String> attributeNames2 = new ArrayList<String>(3);
        attributeNames2.add("Attribute1");
        attributeNames2.add("Attribute2");
        attributeNames2.add("Attribute3");
        try {
            Table t2 = new Table("testTable2",attributeNames2);
            t2.addTuple("value1","value1","value1");
            t2.addTuple("value2","value2","value2");
            String tableString = t2.toSaveString();
            saveTableToFile(t2,"./saves/test.txt");
        } catch(Exception e) {
            System.out.println(e.getMessage());
            throw new Error();
        }
    }
    
    void testLoadTableFromFile()
    {
        try {
            testSaveTable();//make sure we have a file there
            Table testT = loadTableFromFile("./saves/test.txt");
            String stringInFile = readFile("./saves/test.txt");
            is(testT.toSaveString(),stringInFile);
        } catch(Exception e) {
            System.out.println(e.getMessage());
            throw new Error();
        }
    }

    void testExportTableAsTxt()
    {
        List<String> attributeNames2 = new ArrayList<String>(3);
        attributeNames2.add("Attribute1");
        attributeNames2.add("Att2");
        attributeNames2.add("A3");
        try {
            Table t2 = new Table("testTable2",attributeNames2);
            t2.addTuple("value1","val1","v1");
            t2.addTuple("value2","val2","v2");
            exportTableAsTxt(t2, "./exports/test.txt");
        } catch(Exception e) {
            System.out.println(e.getMessage());
            throw new Error();
        }
    }
    
    static void is(Object x, Object y)
    {
        System.out.print("testing " + x.toString() + " = " + y.toString() );
        
        if (x==y || (x != null && x.equals(y)) ) {
            System.out.println("...pass");
            return;
        }
        System.out.print("...fail");
    }
    
    public static void main(String[] args)
    {
        FileHandler fh = new FileHandler();
        fh.testSaveTable();
        fh.testReadFile();
        fh.testLoadTableFromFile();
        fh.testExportTableAsTxt();

    }
}
\end{lstlisting}



\begin{lstlisting}

\end{lstlisting}



\begin{lstlisting}

\end{lstlisting}




\begin{lstlisting}

\end{lstlisting}




\begin{lstlisting}

\end{lstlisting}




\begin{lstlisting}

\end{lstlisting}




\begin{lstlisting}

\end{lstlisting}




\begin{lstlisting}

\end{lstlisting}




\begin{lstlisting}

\end{lstlisting}



\begin{lstlisting}

\end{lstlisting}




\end{document}










